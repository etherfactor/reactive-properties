using EtherGizmos.ReactiveProperties.Generators.Extensions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace EtherGizmos.ReactiveProperties.Generators;

/// <summary>
/// Adds public properties to front private reactive fields.
/// </summary>
[Generator]
public class ReactivePropertyGenerator : ISourceGenerator
{
    /// <inheritdoc/>
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new ReactivePropertySyntaxReceiver());
    }

    /// <inheritdoc/>
    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not ReactivePropertySyntaxReceiver receiver)
            return;

        //Find the reactive property symbol
        var reactivePropertySymbol = context.Compilation.GetTypeByMetadataName("AdaptiveProperties.Reactive.ReactiveProperty`1");
        if (reactivePropertySymbol is null)
            return;

        //Find the reactive list symbol
        var reactiveListPropertySymbol = context.Compilation.GetTypeByMetadataName("AdaptiveProperties.Reactive.ReactiveList`1");
        if (reactiveListPropertySymbol is null)
            return;

        //Find the reactive dictionary symbol
        var reactiveDictionaryPropertySymbol = context.Compilation.GetTypeByMetadataName("AdaptiveProperties.Reactive.ReactiveDictionary`2");
        if (reactiveDictionaryPropertySymbol is null)
            return;

        foreach (var classDeclaration in receiver.CandidateClasses)
        {
            var semanticModel = context.Compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration);

            if (classSymbol is null)
                continue;

            //Get the fully qualified name
            var fullyQualified = classSymbol.ToDisplayString(SymbolDisplayFormat.CSharpErrorMessageFormat);
            var fullyQualifiedSegments = fullyQualified.Split('.');

            //Determine the class name and namespace
            var className = string.Join(".", fullyQualifiedSegments.Last());
            var namespaceName = string.Join(".", fullyQualifiedSegments.Reverse().Skip(1).Reverse());

            var sourceBuilder = new StringBuilder();

            sourceBuilder.AppendLine($"// <auto-generated/>");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine($"using System.Linq;");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine($"namespace {namespaceName}");
            sourceBuilder.AppendLine($"{{");
            sourceBuilder.AppendLine($"    partial class {className}");
            sourceBuilder.AppendLine($"    {{");

            var addedProperties = new List<string>();

            //Iterate through fields
            foreach (var field in classDeclaration.Members.OfType<FieldDeclarationSyntax>())
            {
                foreach (var variable in field.Declaration.Variables)
                {
                    var fieldSymbol = semanticModel.GetDeclaredSymbol(variable) as IFieldSymbol;

                    if (fieldSymbol != null && IsPropertyOrDerived(fieldSymbol.Type, reactivePropertySymbol, context))
                    {
                        if (fieldSymbol.Type is not INamedTypeSymbol namedTypeSymbol)
                            continue;

                        if (IsPropertyOrDerived(fieldSymbol.Type, reactiveListPropertySymbol, context))
                        {
                            //Property is a list

                            sourceBuilder.AppendLine($"        //{string.Join("; ", namedTypeSymbol.TypeArguments.Select(e => e.ToDisplayString()))}");

                            var valueType = namedTypeSymbol.TypeArguments[0];

                            if (valueType != null)
                            {
                                var propertyName = variable.Identifier.Text;
                                sourceBuilder.AppendLine($"        public System.Collections.Generic.IList<{valueType.ToDisplayString()}> {propertyName.ToPascalCase()}");
                                sourceBuilder.AppendLine($"        {{");
                                sourceBuilder.AppendLine($"            get => {propertyName};");
                                sourceBuilder.AppendLine($"            set => {propertyName}.Replace(value);");
                                sourceBuilder.AppendLine($"        }}");

                                addedProperties.Add(propertyName);
                            }
                        }
                        else if (IsPropertyOrDerived(fieldSymbol.Type, reactiveDictionaryPropertySymbol, context))
                        {
                            //Property is a dictionary

                            sourceBuilder.AppendLine($"        //{string.Join("; ", namedTypeSymbol.TypeArguments.Select(e => e.ToDisplayString()))}");

                            var keyType = namedTypeSymbol.TypeArguments[0];
                            var valueType = namedTypeSymbol.TypeArguments[1];

                            if (keyType != null)
                            {
                                var propertyName = variable.Identifier.Text;
                                sourceBuilder.AppendLine($"        public System.Collections.Generic.IDictionary<{keyType.ToDisplayString()}, {valueType.ToDisplayString()}> {propertyName.ToPascalCase()}");
                                sourceBuilder.AppendLine($"        {{");
                                sourceBuilder.AppendLine($"            get => {propertyName};");
                                sourceBuilder.AppendLine($"            set => {propertyName}.Replace(value);");
                                sourceBuilder.AppendLine($"        }}");

                                addedProperties.Add(propertyName);
                            }
                        }
                        else
                        {
                            //Property is anything else

                            sourceBuilder.AppendLine($"        //{string.Join("; ", namedTypeSymbol.TypeArguments.Select(e => e.ToDisplayString()))}");

                            var valueType = namedTypeSymbol.TypeArguments[0];

                            if (valueType != null)
                            {
                                var propertyName = variable.Identifier.Text;
                                sourceBuilder.AppendLine($"        public {valueType.ToDisplayString()} {propertyName.ToPascalCase()}");
                                sourceBuilder.AppendLine($"        {{");
                                sourceBuilder.AppendLine($"            get => {propertyName}.Value;");
                                sourceBuilder.AppendLine($"            set => {propertyName}.Value = value;");
                                sourceBuilder.AppendLine($"        }}");

                                addedProperties.Add(propertyName);
                            }
                        }
                    }
                }
            }

            sourceBuilder.AppendLine($"    }}");
            sourceBuilder.AppendLine($"}}");

            context.AddSource($"{className}_ReactiveProperties.g.cs", SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
        }
    }

    private bool IsPropertyOrDerived(ITypeSymbol propertyType, INamedTypeSymbol comparisonType, GeneratorExecutionContext context)
    {
        //Check if the property itself is the comparison type
        if (SymbolEqualityComparer.Default.Equals(propertyType.OriginalDefinition, comparisonType))
        {
            return true;
        }

        //Traverse base types to check if it inherits from the comparison type
        var currentSymbol = propertyType.BaseType;
        while (currentSymbol != null)
        {
            if (SymbolEqualityComparer.Default.Equals(currentSymbol.OriginalDefinition, comparisonType))
            {
                return true;
            }
            currentSymbol = currentSymbol.BaseType;
        }

        return false;
    }
}
